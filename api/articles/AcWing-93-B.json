{"title":"AcWing-93-B","uid":"5a49e54b325bcc9beaccbd3ef089b665","slug":"AcWing-93-B","date":"2023-03-04T14:23:04.000Z","updated":"2023-03-04T14:27:12.228Z","comments":true,"path":"api/articles/AcWing-93-B.json","keywords":null,"cover":null,"content":"<h1 id=\"cdfs剪枝\">C++DFS+剪枝</h1>\r\n<p>简单<code>DFS+剪枝</code>, (目前来说)剪枝逃不开以下几种情况:<br>\r\n1. 无效性剪枝: 对 0 or 1 不操作.<br>\r\n2. 最优性剪枝: 当深度已经超过之前的最优答案, 不必操作.</p>\r\n<p>但是这样还是不能过.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li><p><strong>启发式剪枝</strong>:\r\n用\"启发式评估函数\"否定非最优解.<br>\r\n即, 当\"当前代价+评估下最优后续操代价 不好于 现有最优解\",\r\n那么不必操作.</p>\r\n<p>关键是<strong>评估函数</strong>,\r\n必须满足<em>充分</em>性和<em>必要</em>性. 这里采用了\"剩余数位\",\r\n因为最优情况下, <em>一次操作增加一个数位</em>.</p></li>\r\n</ol>\r\n<blockquote>\r\n<p>启发式剪枝在这里可以替代最优性剪枝.</p>\r\n<p>为保证思维的体现, 使用了若干专业术语;\r\n部分思路来源于y总讲解;有错请指出; 本人初二, 能力有限, 请谅解.</p>\r\n</blockquote>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst long long int MAXN=19+1,INF=9223372036854775807LL; // INT64_MAX\n\nlong long int n,xx,ans=INF;\nauto f(int deepth, long long int x)\n{\n  bool st[12]={0};// 桶自动去重\n  int cnt=0; // 统计数位\n  for(long long int y=x;y;++cnt,st[y%10]=true,y/=10);\n  // 这里y要用long long. 我TM排了好久...无语. \n  // 熟悉的小调再次响起, \n  // \"十年~OI~一场空~~, 不开~longlong~见祖宗~~. \"\n  \n  if(cnt&gt;=n)\n  {\n    ans=ans&gt;deepth?deepth:ans;\n    //cout&lt;&lt;ans&lt;&lt;\",\"&lt;&lt;x&lt;&lt;\"\\n\"; //DEBUG\n    return;\n  }\n  if(deepth+n-cnt&gt;=ans)return;// 启发式剪枝\n  \n  for(int i=9;i&gt;=2;--i)\n    if(st[i])\n      f(deepth+1,x*i);\n  // 大数优先, 使局部最优\n  // 但是此题有后效性, 局部最优不一定全局最优\n  // 比方样例3. \n}\n\nint main()\n{\n  cin&gt;&gt;n&gt;&gt;xx;\n  f(0,xx);\n  if(ans==INF)cout&lt;&lt;-1;\n  else\n  {\n    cout&lt;&lt;ans;\n  }\n\n}</code></pre>\r\n","text":"C++DFS+剪枝 简单DFS+剪枝, (目前来说)剪枝逃不开以下几种情况: 1. 无效性剪枝: 对 0 or 1 不操作. 2. 最优性剪枝: 当深度已经超过之前的最优答案, 不必操作. 但是这样还是不能过. 启发式剪枝: 用\"启发式评估函数\"否定非最优解. 即, 当\"当前代价...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#cdfs%E5%89%AA%E6%9E%9D\"><span class=\"toc-text\">C++DFS+剪枝</span></a></li></ol>","author":{"name":"YingHN","slug":"blog-author","avatar":"https://s2.loli.net/2022/12/24/vS8KdpjE9WVInX2.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"二叉堆模板","uid":"fdb3deac27eca391f3bea9b5599f90c4","slug":"二叉堆模板","date":"2023-02-11T11:51:32.000Z","updated":"2023-02-11T11:52:00.327Z","comments":true,"path":"api/articles/二叉堆模板.json","keywords":null,"cover":null,"text":"二叉堆模板 #include &lt;bits/stdc++.h&gt; using namespace std; class Heap // the biggest one is at the top of the heap { public: vector&lt;int&gt...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"YingHN","slug":"blog-author","avatar":"https://s2.loli.net/2022/12/24/vS8KdpjE9WVInX2.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}