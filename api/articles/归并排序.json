{"title":"归并排序","uid":"c668d79bcd807cc57a11ce29c7e08a39","slug":"归并排序","date":"2022-08-04T01:29:01.000Z","updated":"2022-08-05T03:48:27.070Z","comments":true,"path":"api/articles/归并排序.json","keywords":null,"cover":[],"content":"<h1 id=\"归并排序\">归并排序</h1>\r\n<ul>\r\n<li>思想: 对左右区间进行排序,再合并区间,如图<br>\r\n<img src=\"https://s1.328888.xyz/2022/08/04/jbZis.gif\" alt=\"img\"></li>\r\n</ul>\r\n<h2 id=\"递归法\">递归法</h2>\r\n<ul>\r\n<li>实现:<br>\r\n<img src=\"https://s1.328888.xyz/2022/08/04/jb9K5.jpg\" alt=\"jb9K5.jpg\">\r\n<ol type=\"1\">\r\n<li>排序左区间(递归调用)</li>\r\n<li>排序右区间(递归调用)</li>\r\n<li>合并左右区间(调用Marge函数),如图<br>\r\n<img src=\"https://s1.328888.xyz/2022/08/04/jbaso.jpg\" alt=\"img\">\r\n<ol type=\"1\">\r\n<li>逐个比较左右区间最小的数的大小,将较小的放入临时数组</li>\r\n<li>将剩下的加入临时数组</li>\r\n<li>复制临时数组到原数组</li>\r\n</ol></li>\r\n</ol></li>\r\n</ul>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">/* make a generics type, T\n * therefore these FUNCs can used in a more usual way\n * enter https://www.cnblogs.com/wangduo/p/5559260.html for more information\n */\ntemplate &lt;typename T&gt;\nvoid Merge(int l1, int r1, int l2, int r2, vector&lt;T&gt; &amp;a)\n// in this FUNC, we will mix numbers in [l,r)\n{\n  vector&lt;T&gt; t;\n  // mix them by compare to sort\n  int i = l1, j = l2;\n  while (i &lt; r1 &amp;&amp; j &lt; r2)\n    t.push_back(a[i] &lt;= a[j] ? a[i++] : a[j++]);\n  \n  // last step will leave some numbers\n  // so do it now\n  while (i &lt; r1)\n    t.push_back(a[i++]);\n  while (j &lt; r2)\n    t.push_back(a[j++]);\n\n  // copy the sorted vector into the origan vector\n  for (int i = l1; i &lt; r2; ++i)\n    a[i] = t[i - l1];\n}\ntemplate &lt;typename T&gt;\nvoid MergeSort(int l, int r, vector&lt;T&gt; &amp;a)\n// in this FUNC, we will sort numbers in [l,r)\n{\n  // one number is always sorted\n  if (r - l &lt;= 1)\n    return;\n\n  int mid = (l + r) &gt;&gt; 1;\n\n  // sort the left\n  MergeSort(l, mid, a);\n  // sort the right\n  MergeSort(mid, r, a);\n\n  Merge(l, mid, r, a);\n\n  return;\n}</code></pre>\r\n<h2 id=\"迭代法\">迭代法</h2>\r\n<ul>\r\n<li>实现: 方法类似但 <strong>自底向上,\"分\"的过程只有一层</strong></li>\r\n</ul>\r\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">/* make a generics type, T\n * therefore these FUNCs can used in a more usual way\n * enter https://www.cnblogs.com/wangduo/p/5559260.html for more information\n */\ntemplate &lt;typename T&gt;\nvoid Merge(int l1, int r1, int l2, int r2, vector&lt;T&gt; &amp;a)\n// in this FUNC, we will mix numbers in [l,r)\n{\n  vector&lt;T&gt; t;\n  // mix them by compare to sort\n  int i = l1, j = l2;\n  while (i &lt; r1 &amp;&amp; j &lt; r2)\n    t.push_back(a[i] &lt;= a[j] ? a[i++] : a[j++]);\n  \n  // last step will leave some numbers\n  // so do it now\n  while (i &lt; r1)\n    t.push_back(a[i++]);\n  while (j &lt; r2)\n    t.push_back(a[j++]);\n\n  // copy the sorted vector into the origan vector\n  for (int i = l1; i &lt; r2; ++i)\n    a[i] = t[i - l1];\n}\n// you know~\ntemplate &lt;typename T&gt;\nvoid MergeSort(int l, int r, vector&lt;T&gt; &amp;a)\n// in this FUNC, we will sort numbers in [0,n)\n{\n  for (int stepDistance = 1; stepDistance &lt; r; stepDistance += stepDistance)\n  {\n    for (int start = l; start &lt; r; start += (stepDistance &lt;&lt; 1))\n    // start is the start index of the scope which will be sorting\n    {\n      int end = min(start + (stepDistance &lt;&lt; 1), r),\n          // the end index of the scope which will be sorting\n          mid = min(start + stepDistance, r);\n      // the middle index of the scope which will be sorting\n      Merge(start, mid, mid, end, a);\n    }\n  }\n}</code></pre>\r\n<hr>\r\n<p><strong>Thanks</strong></p>\r\n","text":"归并排序 思想: 对左右区间进行排序,再合并区间,如图 递归法 实现: 排序左区间(递归调用) 排序右区间(递归调用) 合并左右区间(调用Marge函数),如图 逐个比较左右区间最小的数的大小,将较小的放入临时数组 将剩下的加入临时数组 复制临时数组到原数组 /* make a ...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%E6%B3%95\"><span class=\"toc-text\">递归法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E6%B3%95\"><span class=\"toc-text\">迭代法</span></a></li></ol></li></ol>","author":{"name":"YingHN","slug":"blog-author","avatar":"https://s2.loli.net/2022/12/24/vS8KdpjE9WVInX2.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"链式前向星模板","uid":"064bcb12611ac81fb6c2cc09b9610e8e","slug":"链式前向星模板","date":"2022-10-25T07:08:55.000Z","updated":"2022-10-26T12:06:05.897Z","comments":true,"path":"api/articles/链式前向星模板.json","keywords":null,"cover":null,"text":"链式前向星模板 代码如下（有权值）使用时节点编号必须从 开始 int cnt, head[MAXN]; struct EDGE { int next; // 同起点(tail)的边 int to; // 有向边所指的点(head)的id int wt; // 权值 }edge[M...","link":"","photos":[],"count_time":{"symbolsCount":865,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Code","slug":"Code","count":8,"path":"api/tags/Code.json"},{"name":"Gragh","slug":"Gragh","count":2,"path":"api/tags/Gragh.json"}],"author":{"name":"YingHN","slug":"blog-author","avatar":"https://s2.loli.net/2022/12/24/vS8KdpjE9WVInX2.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"线性代数（8）-- 线性相关性、生成空间和矩阵基本子空间","uid":"dc447ce158f0155c91faf2394b3c3504","slug":"线性代数（8）-- 线性相关性、生成空间和矩阵基本子空间","date":"2022-07-15T09:29:37.000Z","updated":"2022-07-15T09:33:15.792Z","comments":true,"path":"api/articles/线性代数（8）-- 线性相关性、生成空间和矩阵基本子空间.json","keywords":null,"cover":null,"text":"线性相关性 条件： 没有线性组合能得到0（系数不为0） 判断：将向量组 当作列向量，放入矩阵中 ： 若 零空间仅有0向量，则向量组线性无关 若 列满秩（无自由变量），则向量组线性无关 其他情况，向量组线性相关 向量组生成空间 定义： 仅包含向量组的线性组合的空间 基 定义：是 一...","link":"","photos":[],"count_time":{"symbolsCount":420,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"YingHN","slug":"blog-author","avatar":"https://s2.loli.net/2022/12/24/vS8KdpjE9WVInX2.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}