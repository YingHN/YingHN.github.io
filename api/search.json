[{"id":"e4c59dfa082fcf76b9d2b2a3a9f26de1","title":"游戏人生，终将一事无成","content":"游戏人生，终将一事无成有句话说，时间就是金钱，确实如此吗？其实不然，时间胜过金钱。\n我在学校里，每每一到下课，便听到许多关于游戏的声音，当时就觉得烦不胜烦，总让他们离我远点儿，别在学习的地方谈论游戏。可这些人就像哈巴狗一样，赶也赶不走。当时我是不玩游戏的，便总有这样的声音让我去玩，并不停说着有多好玩。时间长了，什么都会变的，我犹豫了，我会变成那种连我自己都厌恶的人吗？\n我自恃清高，但终究还是随波逐流了。\n是的，游戏好玩，但它也的确不是个好东西。\n有一天起来，我发现自己看不清东西了，起了雾的的视线只能让我勉强辨让出老师的字，我全身都震悚起来，满头大汗，心脏怦怦地跳动，用水冲着我的眼睛，期望冲掉上面的雾；滴几滴以前的消毒眼药水，想杀死挡住我视线的病菌；不停做眼保健操，祈祷它能够自我恢复…然而这些都无济于事，我急了，对我的双眼不再抱有希望，抬起头，向未来眺望——我看不见未来，也看不见希望！今后只能通过两片小小的镜片，再看着多彩的世界。我连自己的眼睛也无法保护，又怎么能在这世界留下什么？我的近视会加重，最终使我变成一个瞎子！\n好，如愿了吧！\n我坐在沙发上，表示破罐子破摔的样子，戴着我的眼镜，思考着怎样在游戏中超过过别人——即使在游戏中，我也是个菜鸡，弱得不成样子。这时我的舅舅走过来，他是一个玩游戏的积年，我正想向他请教，然而话未出口，他却比我先发话了，似乎迫不及待，有什么无比重要的事，“玩什么呢？这游戏，有什么意思吗？”舅舅正色道：“这玩游戏，多是一件霉事！”我马上不解了，他平时也常玩游戏啊，怎么今天，言行怪异？他马上继续说下去，不让我发问：“玩完游戏以后，你又得到什么吗呢？”我愣住了，细想，每每玩完游戏，接临而来的就是一阵空虚。他很懂得循循善诱：“什么也没有吧，一阵空虚，接着还想要续玩？没错吧？”他好继想学会了读心术，直捣我的心窝，我们明白了什么他想要说的。舅舅仿佛知道我的想法，比我自己还要了解我：“每天花很久玩游戏，工作好良心不会痛吗？你玩几万局游戏，你也不能得到什么，除了一副新眼镜，你看一两遍的书，你就能得到许多知识，岂不美哉？“\n他的这一番话，像一柄利刃劈向我，因想起刚学习的《匆匆》，再也没有了想玩游戏的心思，卸载了游戏。是啊，玩游戏的意义在哪里，玩游戏的原因在哪里？资本家们开发了游戏，是为了金钱，为了自己，吸引大量的人玩，引导他们，怂恿他们，把无尽的金钱、时间投进这个无底洞里面。资本家们可能没有想到，他们是如此的自私！社会是一层又一层的人撑起来的，国家是一代又一代的栋梁前仆后继，顶起来的！假若人人都荒废时日，沉迷玩乐，在游戏上花费大量的时间，那么，未来国不将国，人不将人，社会崩塌，国家消失，中国人民伟大复兴又要等到什么时候？我们不能改变别人，只能改变自己！\n温晴的阳光照射着树叶，丛中钻出几对飞鸟；天上的浮云向西飘去，不断变换着形状；西下的斜阳洒下束束暖光，告诫我时间的步伐。舅舅双手撑着膝盖，立起身来，身旁的衣角垂到两旁，远去的身影，被夕阳拉得很长，很长…\n愿惜时如金，出淤泥而不染，立志做国家栋梁！——后记\n\nThe End!\n","slug":"游戏人生，终将一事无成","date":"2022-04-29T12:25:36.000Z","categories_index":"","tags_index":"Literature","author_index":"YingHN"},{"id":"b7a05a9fe53f598334cfcb9273c0d23f","title":"微信抢红包调查报告","content":"关于微信抢红包的调查报告前言：春节临近，由于微信的广泛使用及响应“疫情期间不出门，不聚集”的号召，在微信上抢红包已成常态，想必大家都希望抢到更大的红包，这里就分析一下个人数据，以及如何抢到大红包。\n\n正文：【数据收集】· 据微信官方数据，微信红包额度在0.01 ~ 剩余人均值 * 2之间。E.G: 例如：发100块钱，总共10个红包，那么平均值是10块钱一个，那么发出    来的红包的额度在    0.01元～20元之间波动。 当前面3个红包总共被领了40块钱时，剩下60块钱，总共7个红包，那么    这第四个红包的额    度在：0.01～（60/7*2），即0.01～17.14之间。这样算下去，可能会超过最开始的全部金额，因此到了最后面如果不够这么算，那么会采取如下算法：保证剩余用户能拿到最低1分钱即可。如果前面的人手气不好，那么后面的余额越多，红包额度也就越多，因此实际概率一样的。\n· 实践检验，据以上数据，进行蒙特卡洛模拟，10人抢100,000元红包（仅给出九组数据）模拟100W次，得出九张直方图如下：\n(其中C~K为抢的顺序,纵轴表示此人抢到该金额的频率，横轴表示抢到的金额)\n【总结规律】· __标准差__：后抢的标准差更大，可能抢到大红包，也可能抢到小红包\n· __最大最小值__：第一个抢的人不超过20,000（即100,000&#x2F;10 X 2），后抢才可能抢到大红包\n【得出结论】· 如果你是一个风险规避者，只想要稳稳当当地抢，就先抢吧！\n· 如果你是一个风险偏好者，只是追求体验抢到超级大红包的快感，就后抢吧！\n· 如果想多多抽到手气最佳证明自己的人品，就先抢！\n· 如果在玩手气最佳发红包的游戏，却又只想闷声发大财，就后抢！\n\n致谢：【参考文献】· 微信红包的架构设计简介，来源于Qcon、朱玉华\n https://www.zybuluo.com/yulin718/note/93148\n· 提供研究方向等，来源于毕导（微信公众号名）\nhttps://mp.weixin.qq.com/s?__biz&#x3D;MzUxMjcwMzM2MA&#x3D;&#x3D;&amp;mid&#x3D;2247488767&amp;idx&#x3D;1&amp;sn&#x3D;1581620b38cc68881a9d9e3ba7891b16&amp;chksm&#x3D;f9613a10ce16b306d335b2e50cf2207a3b78311ba24b677c755cefca96707748e65c156c7e9c&amp;scene&#x3D;4&amp;rd2werd&#x3D;1#wechat_redirect\n【使用工具】· 蒙特卡洛模拟工具，Oracle Crystal Ball，来源于Oracle（即甲骨文中国） https://www.oracle.com/cn/applications/crystalball/· Microsoft Excle，来源于Microsoft\n https://www.microsoft.com/zh-cn/microsoft-365/excel\n\n感谢以上人员及文献、工具，感谢您的阅读\n","slug":"微信抢红包调查报告","date":"2022-04-29T11:26:44.000Z","categories_index":"","tags_index":"Entertainmen","author_index":"YingHN"},{"id":"b5394bf4622b0e5f2930e3e8011548af","title":"树状数组模板","content":"初级树状数组模板&#x3D;&#x3D;以区间和为例&#x3D;&#x3D;代码如下~\nint lowbit(int a)\n&#x2F;&#x2F;玄学的运算\n&#123;\n\treturn a &amp; (-a);\n    &#x2F;&#x2F;公式记住\n&#125;\nvoid add(int k, vector&lt;int&gt; &amp;tr, int i)\n&#x2F;&#x2F;单点增加\n&#123;\n\tint n &#x3D; tr.size();\n\tfor(int p &#x3D; i; p &lt;&#x3D; n; p +&#x3D; lowbit(p))\n\t\ttr[p] +&#x3D; k;\n    &#x2F;&#x2F;每次到左上层，加入k\n\treturn;\n&#125;\nint ask(int i, vector&lt;int&gt;&amp; tr)\n&#x2F;&#x2F;求前缀和\n&#123;\n\tint ans &#x3D; 0;\n\tfor(int p &#x3D; i; p; p -&#x3D; lowbit(p))\n\t\tans +&#x3D; tr[p];\n    &#x2F;&#x2F;每次到左下层\n\treturn ans;\n&#125;\nint find(int l, int r, vector&lt;int&gt; &amp;tr)\n&#x2F;&#x2F;求区间和\n&#123;\n\treturn ask(r, tr) - ask(l - 1, tr);\n&#125;\nvoid build(vector&lt;int&gt; &amp;tr, vector&lt;int&gt; a)\n&#x2F;&#x2F;建树\n&#123;\n\tint n &#x3D; a.size();\n\ttr.resize(5 * n, 0);\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tadd(a[i], tr, i);\n&#125;\n\n\n建树只要对&#x3D;&#x3D;每一个数据&#x3D;&#x3D;进行&#x3D;&#x3D;单点修改&#x3D;&#x3D;即可建好以后是这个样子：\n\n单点修改如图：\n\n求前缀和如图：\n\n\nThe End!\n","slug":"树状数组模板","date":"2022-04-28T13:07:35.000Z","categories_index":"","tags_index":"Code","author_index":"YingHN"},{"id":"d9abf5541294ba45cebca6edf6c2825e","title":"这也是璀璨星辰","content":"这也是璀璨星辰早上5点，天才蒙蒙亮，天空是灰色的，有还缀着一颗星。我还在睡梦中，就被人连挺带喊叫醒了。\n我迷迷糊糊只听到叫我收拾东西的声音，我也没力气管发生了什么，正拿起我的书包，耳中又挤进几个字词。一听到。我全身都震动起来，一下子就全醒了，“婺城区”，“封城”，“逃离“……这些可怕的词汇让我恐惧。\n在寒冷、直捣心窝的晨风中，我背着行囊，一声“叔叔好”就坐上他的车，踏上了逃离之路。\n窗外的树林飞驰而过，丛生的灌木上不再有鸟语花香，只见一群人扛着一卷卷网，缠绕在树丛之间。单薄的一层网，封住了那里的人们。\n这就是封城吗？\n目光回转，他戴着一副圆形的眼睛，有一种复古的气息。他入头发一丝丝的契合在他的头上，就那么亮的躺在那里，他的脸上一个个的毛孔清晰可辨，像橘皮上那样，只不过没有那么多。他的头有一点儿方，却又好像不是即回事，可能就是他坚毅的性格造就的吧。他的形象就似乎是一个清代的博学鸿儒。\n想起他们还在封城，我以心中又紧张了起来，感觉这么一辆车赶不上那些志愿者。\n纵使我很急，也没有什么用，他依然慢悠悠地开车，一只手搭在方向盘上，另一只手不知在干些什么。可以看出，他是十分闲致的。\n他这时候转过头来，天空中苍白的光芒经过他的镜片射进我眼里。在这一刻，我突然感觉他十分睿智。\n过了这通济桥，就过了婺城。\n我向前看去，果然有一座桥。\n突然,他电话的音乐声响起来,“喂？”原来是他的妻子打了电话来，正问他要不要也回永康去，”这里又是这样那样的，一天能出了7例，看看婺城吧！学校也都停了，回永康不是很安全？”他的回答却出乎我的意料。“不！”他的眼中闪出坚毅的神态，这不再是苍白的，不再是反光的了，这是金色的，发自他内心的！正当我以为他要以没去处为理由时，他再一次起颠倒了我对他的印象，“就让他封吧！我不想影响我弟弟，也不想影响你哥，更不希望，打搅全永康人民的幸福生活！”他这一句话，掷地有声，铿锵有力！他一句话，不仅把问题上升到家庭层面，也是家族层面，更是联系到了整个城市！他一句话，改变的是他的命运，影响的却是全永康市的命运！\n或许是窗外风大，我眼睛有点儿发酸，用力闭下了眼.\n“通济桥过了！”\n激动的心情充满了我的心底，初升的红日投影在江面上，波光凌凌的江水里，闪耀着西边的繁星与东边的日光，好像多彩的鱼鳞。他，是一个人，但是从他的身上，能看到一束束灿烂的光芒，闪耀着人性光辉的，值得颂扬的奉献精神！他，放弃永康的安全生活，宁愿呆在险象环生的金华，也不愿影响他人，多么高尚啊！令人望尘莫及。这，也是璀璨星辰！\n凌晨5点，在这本是旭日东升的时候，婺城的太阳，却落下了。但我又越发觉得，婺城里，越发闪耀出如此璀璨的星光…\n\nThe End!\n","slug":"这也是璀璨星辰","date":"2022-04-17T10:53:17.000Z","categories_index":"","tags_index":"Literature","author_index":"YingHN"},{"id":"57210e696457a5dab93391574b39f7ca","title":"KMP模板","content":"KMP模板代码如下~\nint KMP(string T, string P)\n&#123;\n    int m &#x3D; P.size();\n    int n &#x3D; T.size();\n    &#x2F;&#x2F;P表示匹配串，长度为 m，T表示原串，长度为n。\n    &#x2F;&#x2F;KMP算法是在T中查找子串P，如果存在，返回这个子串的起始索引，否则返回 -1\n    T &#x3D; &quot; &quot; + T;\n    P &#x3D; &quot; &quot; + P;\n    &#x2F;&#x2F;建立哨兵，使得j从0开始\n    if(m &#x3D;&#x3D; 0)return 0;\n    &#x2F;&#x2F;base case\n    vector&lt;int&gt; next(m + 1, 0);\n    &#x2F;&#x2F;nexti表示在P中，前i个字符组成的子串的最长相同前后缀\n    int i &#x3D; 2, j &#x3D; 0;\n    while(i &lt;&#x3D; m)\n    &#123;\n       while(j &gt; 0 &amp;&amp; P[i] !&#x3D; P[j + 1])\n           j &#x3D; next[j];\n       if(P[i] &#x3D;&#x3D; P[j + 1])\n           j++;\n \t   next[i] &#x3D; j;\n       i++;\n    &#125;\n    &#x2F;&#x2F;dp求解next\n    i &#x3D; 1, j &#x3D; 0;\n    while(i &lt;&#x3D; n)\n    &#123;\n       while(j &gt; 0 &amp;&amp; P[j + 1] !&#x3D; T[i])\n           j &#x3D; next[j];\n       if(P[j + 1] &#x3D;&#x3D; T[i])\n           j++;\n       if(j &#x3D;&#x3D; m)return i - m;\n       i++;\n    &#125;\n    return -1;\n&#125; \n\n\n解析如下：\n1.匹配过程首先在「原串」和「匹配串」分别各自有一个指针指向当前匹配的位置。\n首次匹配的「发起点」是第一个字符 a。显然，后面的 ABCE 都是匹配的，两个指针会同时往右移动。\n在都能匹配上 ABC 的部分，「朴素匹配」和「KMP」并无不同。\n直到出现第一个不同的位置（红标）：\n\n首先匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：\n\n因为__进行下次模式匹配时，没有必要让串 B 中的 A 与主串中的字符 B 和 C 一一匹配__（它们绝不可能相同_），而是__直接去匹配失败位置处的字符A_ .\n到这里，你应该清楚 KMP 为什么相比于朴素解法更快：\n  *因为 KMP __利用已匹配部分中相同的「前缀」和「后缀」__来__加速下一次的匹配__。\n  *因为 KMP 的原串指针__不会进行回溯__。\n第一点很直观，也很好理解。\n我们可以把重点放在第二点上，原串__不回溯__至「发起点」意味着什么？\n其实是意味着：随着匹配过程的进行，原串指针的_不断右移_，我们本质上是在不断地在__否决一些「不可能」的方案。__\n当我们的原串指针从i位置后移到j位置，不仅仅代表着「原串」下标范围为 [i,j)[i,j)的字符与「匹配串」匹配或者不匹配，更是在_否决那些以「原串」下标范围为[i,j)[i,j)为「匹配发起点」的子集。_\n2.next数组的构建\n\n\n\n4.代码实现在实际编码时，通常会__往原串和匹配串头部追加一个空格__（哨兵）。\n目的是让j下标从 0 开始，省去 j 从 -1 开始的麻烦。\n整个过程与上述分析完全一致，一些相关的注释我已经写到代码里。\n\nThe End!\n","slug":"KMP模板","date":"2022-04-17T04:43:16.000Z","categories_index":"","tags_index":"Code","author_index":"YingHN"},{"id":"06a4ad3b5747ac0ceb428e9bf158468a","title":"完全背包模板","content":"完全背包模板\n代码如下\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123; \n    int V, n;\n    cin&gt;&gt;V&gt;&gt;n;\n    int v[n + 1], w[n + 1], dp[V + 1];\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n  \t    cin&gt;&gt;v[i]&gt;&gt;w[i];\n    memset(dp, 0, sizeof(dp));\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#x2F;&#x2F;从01背包改的，就不多说了\n    &#123;\n        for(int j &#x3D; v[i]; j &lt;&#x3D; V; j++)\n        &#x2F;&#x2F;i - 1的状态不复存在了\n        &#x2F;&#x2F;使用i(当前层)的状态\n        &#x2F;&#x2F;因此会重复取\n        &#123;\n            dp[j] &#x3D; max(dp[j - v[i]] + w[i], dp[j]);\n        &#125;\n    &#125;\n    cout&lt;&lt;dp[V];\n&#125;\n\n  \n\nThe End\n","slug":"完全背包模板","date":"2022-04-16T10:48:48.000Z","categories_index":"","tags_index":"Code","author_index":"YingHN"},{"id":"13559706c1940152ddef2d44a414527a","title":"01背包模板","content":"01背包模板话不多说，上代码！！\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    int V, n;\n\tcin&gt;&gt;V&gt;&gt;n;\n    &#x2F;&#x2F;输入背包容量及物品数量\n\tint v[n + 1], w[n + 1], dp[V + 1];\n    &#x2F;&#x2F;vi表示第i个物品的体积\n    &#x2F;&#x2F;wi表示第i个物品的价值\n    &#x2F;&#x2F;dpi表示花费i体积所能获得的最大价值\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tcin&gt;&gt;v[i]&gt;&gt;w[i];\n\tmemset(dp, 0, sizeof(dp));\n    &#x2F;&#x2F;初始化\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#x2F;&#x2F;对于每个物品有取或不取两种选择\n    &#x2F;&#x2F;因此枚举正在对第i个物品进行决策\n\t&#123;\n  \t\tfor(int j &#x3D; V; j &gt;&#x3D; v[i]; j--)\n        &#x2F;&#x2F;枚举第i个物品所花费的体积\n        &#x2F;&#x2F;从后往前使得上一个物品的决策仍可以使用\n\t\t&#123;\n\t\t\tdp[j] &#x3D; max(dp[j - v[i]] + w[i], dp[j]);\n\t\t&#125;\n\t&#125;\n\tcout&lt;&lt;dp[V];\n    &#x2F;&#x2F;输出\n&#125;\n\n\nThanks For Your Reading!\n","slug":"01背包模板","date":"2022-04-16T10:00:52.000Z","categories_index":"","tags_index":"Code","author_index":"YingHN"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-04-09T00:50:51.278Z","categories_index":"","tags_index":"","author_index":"YingHN"}]