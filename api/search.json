[{"id":"57210e696457a5dab93391574b39f7ca","title":"KMP模板","content":"KMP模板代码如下~\nint KMP(string T, string P)\n&#123;\n    int m &#x3D; P.size();\n    int n &#x3D; T.size();\n    &#x2F;&#x2F;P表示匹配串，长度为 m，T表示原串，长度为n。\n    &#x2F;&#x2F;KMP算法是在T中查找子串P，如果存在，返回这个子串的起始索引，否则返回 -1\n    T &#x3D; &quot; &quot; + T;\n    P &#x3D; &quot; &quot; + P;\n    &#x2F;&#x2F;建立哨兵，使得j从0开始\n    if(m &#x3D;&#x3D; 0)return 0;\n    &#x2F;&#x2F;base case\n    vector&lt;int&gt; next(m + 1, 0);\n    &#x2F;&#x2F;nexti表示在P中，前i个字符组成的子串的最长相同前后缀\n    int i &#x3D; 2, j &#x3D; 0;\n    while(i &lt;&#x3D; m)\n    &#123;\n       while(j &gt; 0 &amp;&amp; P[i] !&#x3D; P[j + 1])\n           j &#x3D; next[j];\n       if(P[i] &#x3D;&#x3D; P[j + 1])\n           j++;\n \t   next[i] &#x3D; j;\n       i++;\n    &#125;\n    &#x2F;&#x2F;dp求解next\n    i &#x3D; 1, j &#x3D; 0;\n    while(i &lt;&#x3D; n)\n    &#123;\n       while(j &gt; 0 &amp;&amp; P[j + 1] !&#x3D; T[i])\n           j &#x3D; next[j];\n       if(P[j + 1] &#x3D;&#x3D; T[i])\n           j++;\n       if(j &#x3D;&#x3D; m)return i - m;\n       i++;\n    &#125;\n    return -1;\n&#125; \n\n\n解析如下：\n1.匹配过程首先在「原串」和「匹配串」分别各自有一个指针指向当前匹配的位置。\n首次匹配的「发起点」是第一个字符 a。显然，后面的 ABCE 都是匹配的，两个指针会同时往右移动。\n在都能匹配上 ABC 的部分，「朴素匹配」和「KMP」并无不同。\n直到出现第一个不同的位置（红标）：\n\n首先匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：\n\n因为__进行下次模式匹配时，没有必要让串 B 中的 A 与主串中的字符 B 和 C 一一匹配__（它们绝不可能相同_），而是__直接去匹配失败位置处的字符A_ .\n到这里，你应该清楚 KMP 为什么相比于朴素解法更快：\n  *因为 KMP __利用已匹配部分中相同的「前缀」和「后缀」__来__加速下一次的匹配__。\n  *因为 KMP 的原串指针__不会进行回溯__。\n第一点很直观，也很好理解。\n我们可以把重点放在第二点上，原串__不回溯__至「发起点」意味着什么？\n其实是意味着：随着匹配过程的进行，原串指针的_不断右移_，我们本质上是在不断地在__否决一些「不可能」的方案。__\n当我们的原串指针从i位置后移到j位置，不仅仅代表着「原串」下标范围为 [i,j)[i,j)的字符与「匹配串」匹配或者不匹配，更是在_否决那些以「原串」下标范围为[i,j)[i,j)为「匹配发起点」的子集。_\n2.next数组的构建\n\n\n\n4.代码实现在实际编码时，通常会__往原串和匹配串头部追加一个空格__（哨兵）。\n目的是让j下标从 0 开始，省去 j 从 -1 开始的麻烦。\n整个过程与上述分析完全一致，一些相关的注释我已经写到代码里。\n\nThe End!\n","slug":"KMP模板","date":"2022-04-17T04:43:16.000Z","categories_index":"","tags_index":"Code","author_index":"YingHN"},{"id":"06a4ad3b5747ac0ceb428e9bf158468a","title":"完全背包模板","content":"完全背包模板\n代码如下\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123; \n    int V, n;\n    cin&gt;&gt;V&gt;&gt;n;\n    int v[n + 1], w[n + 1], dp[V + 1];\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n  \t    cin&gt;&gt;v[i]&gt;&gt;w[i];\n    memset(dp, 0, sizeof(dp));\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#x2F;&#x2F;从01背包改的，就不多说了\n    &#123;\n        for(int j &#x3D; v[i]; j &lt;&#x3D; V; j++)\n        &#x2F;&#x2F;i - 1的状态不复存在了\n        &#x2F;&#x2F;使用i(当前层)的状态\n        &#x2F;&#x2F;因此会重复取\n        &#123;\n            dp[j] &#x3D; max(dp[j - v[i]] + w[i], dp[j]);\n        &#125;\n    &#125;\n    cout&lt;&lt;dp[V];\n&#125;\n\n  \n\nThe End\n","slug":"完全背包模板","date":"2022-04-16T10:48:48.000Z","categories_index":"","tags_index":"Code","author_index":"YingHN"},{"id":"13559706c1940152ddef2d44a414527a","title":"01背包模板","content":"01背包模板话不多说，上代码！！\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    int V, n;\n\tcin&gt;&gt;V&gt;&gt;n;\n    &#x2F;&#x2F;输入背包容量及物品数量\n\tint v[n + 1], w[n + 1], dp[V + 1];\n    &#x2F;&#x2F;vi表示第i个物品的体积\n    &#x2F;&#x2F;wi表示第i个物品的价值\n    &#x2F;&#x2F;dpi表示花费i体积所能获得的最大价值\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tcin&gt;&gt;v[i]&gt;&gt;w[i];\n\tmemset(dp, 0, sizeof(dp));\n    &#x2F;&#x2F;初始化\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#x2F;&#x2F;对于每个物品有取或不取两种选择\n    &#x2F;&#x2F;因此枚举正在对第i个物品进行决策\n\t&#123;\n  \t\tfor(int j &#x3D; V; j &gt;&#x3D; v[i]; j--)\n        &#x2F;&#x2F;枚举第i个物品所花费的体积\n        &#x2F;&#x2F;从后往前使得上一个物品的决策仍可以使用\n\t\t&#123;\n\t\t\tdp[j] &#x3D; max(dp[j - v[i]] + w[i], dp[j]);\n\t\t&#125;\n\t&#125;\n\tcout&lt;&lt;dp[V];\n    &#x2F;&#x2F;输出\n&#125;\n\n\nThanks For Your Reading!\n","slug":"01背包模板","date":"2022-04-16T10:00:52.000Z","categories_index":"","tags_index":"Code","author_index":"YingHN"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-04-09T00:50:51.278Z","categories_index":"","tags_index":"","author_index":"YingHN"}]